# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# SPDX-License-Identifier: BSD-3-Clause

"""
Configuration for RedRhex hexapod robot environment with RHex-style wheg locomotion.

RHex 機器人核心概念：
- 每隻腳的主驅動關節持續旋轉（像輪子），而非傳統步行
- 使用交替三足步態（alternating tripod gait）
- 半圓形腿與地面的接觸產生前進位移

關節分組：
- 主驅動關節（連續旋轉）: 15, 12, 18, 23, 24, 7
  - Tripod A: 15, 18, 24
  - Tripod B: 12, 23, 7
- ABAD 關節（外展/內收，RL 探索）: 14, 11, 17, 22, 21, 6
- 避震關節（被動/高剛性）: 5, 13, 25, 26, 27, 8
"""

from __future__ import annotations

import math
import os
import isaaclab.sim as sim_utils

# Get the USD path - config file is at source/RedRhex/RedRhex/tasks/direct/redrhex/
# USD file is at project root: /home/jasonliao/RedRhex/RedRhex/RedRhex.usd
_THIS_DIR = os.path.dirname(os.path.abspath(__file__))
_REDRHEX_USD_PATH = os.path.normpath(os.path.join(
    _THIS_DIR, "..", "..", "..", "..", "..", "..", "RedRhex.usd"
))
from isaaclab.actuators import ImplicitActuatorCfg
from isaaclab.assets import ArticulationCfg
from isaaclab.envs import DirectRLEnvCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim import SimulationCfg
from isaaclab.terrains import TerrainImporterCfg, TerrainGeneratorCfg
from isaaclab.terrains.height_field import hf_terrains_cfg as hf  # 高度場地形
from isaaclab.terrains.trimesh import mesh_terrains_cfg as mesh    # 網格地形
from isaaclab.utils import configclass

from isaaclab.sensors import ContactSensorCfg

# =============================================================================
# 【機器人本體配置】定義 RedRhex 機器人的物理屬性
# =============================================================================
# ArticulationCfg = 關節式機器人的配置類別
# 這裡定義了機器人的：重量、材質、物理行為、初始姿態、馬達參數等

REDRHEX_CFG = ArticulationCfg(
    # -------------------------------------------------------------------------
    # 【生成設定】從 USD 文件載入 3D 模型
    # -------------------------------------------------------------------------
    spawn=sim_utils.UsdFileCfg(
        usd_path=_REDRHEX_USD_PATH,           # 3D 模型文件路徑
        activate_contact_sensors=True,         # 啟用接觸感測器（檢測碰撞）
        
        # 【質量屬性】決定機器人有多重
        # 重量很重要！太輕會不穩定，太重會難以移動
        mass_props=sim_utils.MassPropertiesCfg(
            # 整機目標質量約 13.5-15 公斤：
            #   - 機身約 12 公斤
            #   - 6 隻腿各約 0.35 公斤
            # 設定較高密度可以增加機器人對地面的壓力，防止亂跳
            density=2500.0,  # 密度（公斤/立方公尺）- 決定機身約 12 公斤
        ),
        
        # 【剛體物理屬性】決定機器人如何回應物理力
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,              # 保持重力（不能飛！）
            retain_accelerations=False,         # 不保留加速度（節省記憶體）
            linear_damping=0.1,                 # 線性阻尼：減緩直線運動，數值越大移動越慢
            angular_damping=0.2,                # 角阻尼：減緩旋轉運動
            max_linear_velocity=10.0,           # 最大移動速度（公尺/秒）
            max_angular_velocity=20.0,          # 最大旋轉速度（弧度/秒），要夠大才能讓腿轉動
            max_depenetration_velocity=1.0,     # 穿透恢復速度：當物體意外重疊時，分開的速度
        ),
        
        # 【關節系統屬性】決定關節如何運作
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False,       # 關閉自身碰撞（防止腿撞到身體造成不穩定）
            solver_position_iteration_count=16,  # 位置求解器迭代次數：越多越精確但越慢
            solver_velocity_iteration_count=8,   # 速度求解器迭代次數
            fix_root_link=False,                 # 機器人可以自由移動（不固定在原地）
        ),
    ),
    # -------------------------------------------------------------------------
    # 【初始狀態】機器人在模擬開始時的位置和姿態
    # -------------------------------------------------------------------------
    init_state=ArticulationCfg.InitialStateCfg(
        # 初始位置 (x, y, z)：放在空中 0.5 公尺高，讓它自然落下
        pos=(0.0, 0.0, 0.3),
        
        # 初始旋轉（四元數格式 w, x, y, z）
        # 這個數值讓機器人繞 X 軸旋轉 90 度，調整到正確朝向
        rot=(0.7071068, 0.7071068, 0.0, 0.0),
        
        # 【關節初始位置】每個關節開始時的角度
        # 注意：USD 文件顯示的是「度」，但程式要用「弧度」
        # 轉換公式：弧度 = 度數 × π ÷ 180
        joint_pos={
            # =====================================================
            # 主驅動關節 (Main Drive) - 控制腿的旋轉
            # 右側腿：初始角度 45°
            # 左側腿：初始角度 -45°（方向相反）
            # =====================================================
            "Revolute_15": 45.0 * math.pi / 180,   # 右前腿 - 45°
            "Revolute_12": 45.0 * math.pi / 180,   # 右後腿 - 45°
            "Revolute_7": 45.0 * math.pi / 180,    # 右中腿 - 45°
            "Revolute_18": -45.0 * math.pi / 180,  # 左前腿 - -45°
            "Revolute_23": -45.0 * math.pi / 180,  # 左中腿 - -45°
            "Revolute_24": -45.0 * math.pi / 180,  # 左後腿 - -45°
            
            # =====================================================
            # ABAD 關節 - 控制腿的外展/內收
            # 全部從 0° 開始（腿朝正下方）
            # =====================================================
            "Revolute_14": 0.0,  # 右前腿
            "Revolute_6": 0.0,   # 右中腿
            "Revolute_11": 0.0,  # 右後腿
            "Revolute_17": 0.0,  # 左前腿
            "Revolute_22": 0.0,  # 左中腿
            "Revolute_21": 0.0,  # 左後腿
            
            # =====================================================
            # 避震關節 (Damper) - 吸收衝擊用
            # 這些關節會被鎖定，保持固定角度
            # =====================================================
            "Revolute_5": 45.0 * math.pi / 180,    # 45°
            "Revolute_13": -45.0 * math.pi / 180,  # -45°
            "Revolute_8": 45.0 * math.pi / 180,    # 45°
            "Revolute_25": 45.0 * math.pi / 180,   # 45°
            "Revolute_26": 45.0 * math.pi / 180,   # 45°
            "Revolute_27": 45.0 * math.pi / 180,   # 45°
        },
        # 所有關節的初始速度都是 0（靜止狀態）
        joint_vel={".*": 0.0},
    ),
    
    # 關節位置限制的軟化係數（0.9 = 允許到達 90% 的極限位置）
    soft_joint_pos_limit_factor=0.9,
    # -------------------------------------------------------------------------
    # 【致動器配置】定義三種不同類型關節的馬達特性
    # -------------------------------------------------------------------------
    # 致動器（Actuator）= 讓關節動起來的「馬達」
    # 每種關節因為功能不同，需要不同的馬達設定
    actuators={
        # =================================================================
        # 【主驅動馬達】讓腿持續旋轉的關鍵！
        # =================================================================
        # 控制方式：速度控制（告訴馬達要轉多快）
        # 
        # ★★★ 重要原理（初學者必讀）★★★
        # 這裡用的是「隱式致動器」(Implicit Actuator)
        # 力矩計算公式：力矩 = 阻尼 × (目標速度 - 當前速度)
        # 
        # 白話解釋：
        # - 如果目標速度是 10，當前速度是 0
        # - 力矩 = 50 × (10 - 0) = 500 牛頓米
        # - 阻尼(damping)越大，馬達推力越強
        # - 如果阻尼太低，腿會轉不動！
        "main_drive": ImplicitActuatorCfg(
            # 這 6 個關節是主驅動關節
            joint_names_expr=[
                "Revolute_15", "Revolute_12", "Revolute_18",
                "Revolute_23", "Revolute_24", "Revolute_7"
            ],
            effort_limit=100.0,      # 最大力矩限制（牛頓米）- 馬達能出的最大力
            velocity_limit=30.0,     # 最大轉速限制（弧度/秒）
            stiffness=0.0,           # 剛性 = 0，表示純速度控制（不追蹤位置）
            damping=50.0,            # ★ 阻尼值：決定馬達推力強度！數值越大越有力
        ),
        
        # =================================================================
        # 【ABAD 馬達】讓腿往外或往內擺動
        # =================================================================
        # 控制方式：位置控制（告訴馬達要擺到什麼角度）
        # 用途：調整機器人轉彎、側移、保持平衡
        "abad": ImplicitActuatorCfg(
            joint_names_expr=[
                "Revolute_14", "Revolute_11", "Revolute_17",
                "Revolute_22", "Revolute_21", "Revolute_6"
            ],
            effort_limit=8.0,        # 力矩限制（較小，因為只需微調）
            velocity_limit=5.0,      # 速度限制（不需要快速擺動）
            stiffness=40.0,          # 較高剛性：讓關節能精準到達目標位置
            damping=4.0,             # 中等阻尼：防止過度震盪
        ),
        
        # =================================================================
        # 【避震關節】被動式，不由 AI 控制
        # =================================================================
        # 控制方式：固定位置（用極高剛性鎖住）
        # 用途：像汽車避震器一樣吸收衝擊，保護機身
        # 
        # 設計理念：
        # - 這些關節不在 AI 的「動作空間」中
        # - 用超高剛性讓它們保持初始角度
        # - 高阻尼防止任何振動
        "damper": ImplicitActuatorCfg(
            joint_names_expr=[
                "Revolute_5", "Revolute_13", "Revolute_25",
                "Revolute_26", "Revolute_27", "Revolute_8"
            ],
            effort_limit=50.0,       # 高力矩：能抵抗外力維持位置
            velocity_limit=1.0,      # 極低速度限制：防止快速移動
            stiffness=200.0,         # 超高剛性：像彈簧一樣強力拉回原位
            damping=20.0,            # 高阻尼：吸收任何震動
        ),
    },
)


@configclass
class RedrhexEnvCfg(DirectRLEnvCfg):
    """
    ==========================================================================
    RedRhex 強化學習環境配置
    ==========================================================================
    
    【什麼是強化學習環境？】
    想像你在訓練一隻小狗：
    - 環境 = 小狗活動的場地
    - 觀察 = 小狗看到的東西（地面、障礙物...）
    - 動作 = 小狗能做的事（走、跑、轉彎...）
    - 獎勵 = 做對事給零食，做錯扣分
    
    這個類別定義了機器人的「訓練場」：
    1. 機器人能「看到」什麼（觀察空間）
    2. 機器人能「做」什麼（動作空間）
    3. 什麼是「好」的行為（獎勵函數）
    
    【控制架構說明】
    ┌─────────────────────────────────────────────────────────────────┐
    │ 關節類型      │ 控制方式      │ AI 輸出內容                      │
    ├─────────────────────────────────────────────────────────────────┤
    │ 主驅動關節    │ 速度控制      │ 目標角速度（轉多快）             │
    │ ABAD 關節     │ 位置控制      │ 目標位置偏移（擺多少度）         │
    │ 避震關節      │ 被動          │ 不控制（不在動作空間中）         │
    └─────────────────────────────────────────────────────────────────┘
    
    【機器人重量參考】（使用 UPE 材質，密度約 940 kg/m³）
    - 機身 (base_link): 約 12 公斤
    - 每隻腿 (C-leg): 約 0.35 公斤
    - 整機總重量: 約 14 公斤
    """

    # =========================================================================
    # 【基本環境設定】
    # =========================================================================
    
    # 控制頻率計算：
    # - 物理模擬以 120 Hz 運行（每秒 120 次物理計算）
    # - decimation = 2 表示每 2 次物理計算，AI 才做一次決策
    # - 所以 AI 控制頻率 = 120 ÷ 2 = 60 Hz（每秒決策 60 次）
    decimation = 2
    
    # 每個訓練回合（episode）持續 30 秒
    # 越長的回合讓機器人有更多時間學習和探索
    episode_length_s = 60

    # =========================================================================
    # 【動作空間】AI 能控制的東西
    # =========================================================================
    # 總共 12 個動作：
    # - 6 個主驅動關節的目標速度
    # - 6 個 ABAD 關節的目標位置
    # 
    # AI 神經網路會輸出 12 個數字（範圍 -1 到 +1）
    # 這些數字會被縮放成實際的速度或角度
    action_space = 12
    
    # =========================================================================
    # 【觀察空間】AI 能「看到」的資訊
    # =========================================================================
    # 機器人需要知道自己的狀態才能做出正確決策
    # 
    # 觀察內容詳細說明：
    # ┌──────────────────────────────────────────────────────────────────────┐
    # │ 資訊類型              │ 維度  │ 說明                                 │
    # ├──────────────────────────────────────────────────────────────────────┤
    # │ base_lin_vel          │  3    │ 機身線速度 (x, y, z 方向)            │
    # │ base_ang_vel          │  3    │ 機身角速度 (繞 x, y, z 軸)           │
    # │ projected_gravity     │  3    │ 重力方向（用來判斷傾斜程度）         │
    # │ main_drive_pos_sin    │  6    │ 主驅動關節位置的正弦值（循環相位）   │
    # │ main_drive_pos_cos    │  6    │ 主驅動關節位置的餘弦值（循環相位）   │
    # │ main_drive_vel        │  6    │ 主驅動關節的當前速度                 │
    # │ abad_pos              │  6    │ ABAD 關節的當前位置                  │
    # │ abad_vel              │  6    │ ABAD 關節的當前速度                  │
    # │ velocity_command      │  3    │ 目標速度命令 (vx, vy, wz)            │
    # │ gait_phase            │  2    │ 步態相位 (sin/cos 表示)              │
    # │ last_actions          │ 12    │ 上一次的動作（讓動作更平滑）         │
    # ├──────────────────────────────────────────────────────────────────────┤
    # │ 總計                  │ 56    │ 3+3+3+6+6+6+6+6+3+2+12 = 56          │
    # └──────────────────────────────────────────────────────────────────────┘
    # 
    # 為什麼用 sin/cos 表示旋轉位置？
    # 因為旋轉是循環的（0° = 360°），用 sin/cos 可以讓 AI 更容易理解循環性質
    observation_space = 56
    
    # state_space 用於非對稱訓練（老師-學生架構），這裡不使用
    state_space = 0

    # =========================================================================
    # 【物理模擬設定】定義虛擬世界的物理規則
    # =========================================================================
    sim: SimulationCfg = SimulationCfg(
        # 模擬時間步長：每秒 120 次物理計算
        # 越小越精確，但計算量越大
        dt=1 / 250,
        
        # 渲染間隔：每 2 次物理計算才更新一次畫面（節省效能）
        render_interval=2,
        
        # 重力加速度 (x, y, z) 單位：公尺/秒²
        # z = -9.81 表示向下的地球重力
        gravity=(0.0, 0.0, -9.81),
        
        # 【物理材質】定義物體表面的摩擦和彈性
        # ★ 貼近現實橡膠輪胎/抖青地面的摩擦係數 ★
        physics_material=sim_utils.RigidBodyMaterialCfg(
            # 摩擦力合併模式：當兩個物體接觸時，如何計算總摩擦力
            # "multiply" = 兩者相乘（比較保守）
            friction_combine_mode="multiply",
            restitution_combine_mode="multiply",
            
            # 靜摩擦係數：物體靜止時需要多大力才能推動
            # 橡膠 vs 抖青 約 0.8~1.2，設為 1.2 以增強抓地力
            static_friction=1.2,
            
            # 動摩擦係數：物體移動時的阻力
            # 通常比靜摩擦稍低
            dynamic_friction=1.0,
            
            # 彈性係數：碰撞後反彈的程度
            # 0 = 完全不彈（像黏土）
            # 1 = 完全彈回（像超級彈力球）
            restitution=0.0,  # 設為 0 防止機器人亂跳
        ),
    )

    # =========================================================================
    # 【機器人配置】引用前面定義的機器人設定
    # =========================================================================
    # replace() 方法會複製 REDRHEX_CFG，但把路徑改成環境專用的路徑
    # "/World/envs/env_.*/Robot" 是一個正則表達式模板
    # 當有多個環境時，會自動變成 env_0, env_1, env_2...
    robot_cfg: ArticulationCfg = REDRHEX_CFG.replace(prim_path="/World/envs/env_.*/Robot")

    # =========================================================================
    # 【接觸感測器配置】偵測機器人是否碰到東西
    # =========================================================================
    # 這很重要！用來檢測：
    # - 身體是否摔倒撞到地面（這是壞事）
    # - 腿是否正確接觸地面（這是好事）
    contact_sensor: ContactSensorCfg = ContactSensorCfg(
        # 監測機器人所有部位的碰撞
        prim_path="/World/envs/env_.*/Robot/.*",
        
        # 保留最近 3 筆碰撞紀錄
        history_length=3,
        
        # 更新頻率：0.0 表示每次物理計算都更新
        update_period=0.0,
        
        # 追蹤腳在空中的時間（用於分析步態）
        track_air_time=True,
    )
    
    # 身體部位名稱 - 這些部位不應該碰到地面！
    # 如果 base_link（主機身）碰到地面，表示機器人摔倒了
    body_names = ["base_link"]
    
    # 腿部名稱 - 這些部位碰到地面是正常的
    # 使用正則表達式匹配所有包含 "leg" 的部位
    leg_names = [".*leg.*", ".*Leg.*"]

    # =========================================================================
    # 【場景配置】設定訓練環境
    # =========================================================================
    scene: InteractiveSceneCfg = InteractiveSceneCfg(
        # 同時模擬 4096 個環境！
        # 這就是 GPU 平行訓練的威力：一次訓練數千個機器人
        num_envs=4096,
        
        # 每個環境之間的間距（公尺）
        # 太近會互相干擾，太遠會浪費空間
        env_spacing=2.5,
        
        # 複製物理設定到所有環境（加速模擬）
        replicate_physics=True,
    )

    # =========================================================================
    # 【地形配置】設定機器人腳下的地面
    # =========================================================================
    # 
    # ★★★ terrain_type 三種選項 ★★★
    # ┌─────────────────────────────────────────────────────────────────────┐
    # │ terrain_type  │ 說明                                               │
    # ├─────────────────────────────────────────────────────────────────────┤
    # │ "plane"       │ 平坦地面（預設，最簡單）                            │
    # │ "generator"   │ 程序化生成地形（需配合 terrain_generator 參數）     │
    # │ "usd"         │ 從 USD 檔案載入自訂地形（需配合 usd_path 參數）     │
    # └─────────────────────────────────────────────────────────────────────┘
    #
    # ★★★ 如何使用 "generator" 生成複雜地形 ★★★
    #
    # 步驟 1: 把 terrain_type 改成 "generator"
    # 步驟 2: 加入 terrain_generator 參數（見下方範例）
    #
    # 可用的子地形類型：
    # ┌─────────────────────────────────────────────────────────────────────┐
    # │ 高度場地形 (hf.xxx)           │ 說明                               │
    # ├─────────────────────────────────────────────────────────────────────┤
    # │ hf.HfRandomUniformTerrainCfg  │ 隨機高低起伏地形                   │
    # │ hf.HfPyramidSlopedTerrainCfg  │ 金字塔斜坡                         │
    # │ hf.HfPyramidStairsTerrainCfg  │ 金字塔階梯                         │
    # │ hf.HfDiscreteObstaclesTerrainCfg │ 隨機障礙物                      │
    # │ hf.HfWaveTerrainCfg           │ 波浪地形                           │
    # │ hf.HfSteppingStonesTerrainCfg │ 踏腳石                             │
    # └─────────────────────────────────────────────────────────────────────┘
    # ┌─────────────────────────────────────────────────────────────────────┐
    # │ 網格地形 (mesh.xxx)           │ 說明                               │
    # ├─────────────────────────────────────────────────────────────────────┤
    # │ mesh.MeshPlaneTerrainCfg      │ 平坦網格                           │
    # │ mesh.MeshPyramidStairsTerrainCfg │ 金字塔階梯                      │
    # │ mesh.MeshRandomGridTerrainCfg │ 隨機格子高低                       │
    # │ mesh.MeshRailsTerrainCfg      │ 軌道地形                           │
    # │ mesh.MeshPitTerrainCfg        │ 坑洞地形                           │
    # │ mesh.MeshBoxTerrainCfg        │ 箱子/台階                          │
    # │ mesh.MeshGapTerrainCfg        │ 間隙地形                           │
    # │ mesh.MeshStarTerrainCfg       │ 星形地形                           │
    # └─────────────────────────────────────────────────────────────────────┘
    #
    # =========================================================================
    
    # -------------------------------------------------------------------------
    # 【範例 1】平坦地面（目前使用中）
    # ★ 貼近現實橡膠輪胎/抖青地面的摩擦係數 ★
    terrain = TerrainImporterCfg(
        prim_path="/World/ground",
        terrain_type="plane",
        collision_group=-1,
        physics_material=sim_utils.RigidBodyMaterialCfg(
            friction_combine_mode="multiply",
            restitution_combine_mode="multiply",
            static_friction=1.2,   # 提高：橡膠 vs 抖青 約 0.8~1.2
            dynamic_friction=1.0,  # 提高
        ),
        debug_vis=False,
    )
    # -------------------------------------------------------------------------

    # -------------------------------------------------------------------------
    # 【範例 2】金字塔階梯地形（取消註解即可使用）
    # -------------------------------------------------------------------------
    # terrain = TerrainImporterCfg(
    #     prim_path="/World/ground",
    #     terrain_type="generator",  # ← 改成 generator
    #     terrain_generator=TerrainGeneratorCfg(
    #         size=(8.0, 8.0),        # 每個子地形的大小 (寬, 長) 公尺
    #         num_rows=4,             # 地形網格的行數
    #         num_cols=4,             # 地形網格的列數
    #         border_width=0.5,       # 邊界寬度
    #         curriculum=False,       # 是否啟用課程學習（難度遞增）
    #         sub_terrains={
    #             "pyramid_stairs": hf.HfPyramidStairsTerrainCfg(
    #                 proportion=1.0,           # 這種地形佔 100%
    #                 step_height_range=(0.05, 0.15),  # 階梯高度 5~15 公分
    #                 step_width=0.3,           # 階梯寬度 30 公分
    #                 platform_width=1.0,       # 中央平台寬度
    #             ),
    #         },
    #     ),
    #     collision_group=-1,
    #     physics_material=sim_utils.RigidBodyMaterialCfg(
    #         friction_combine_mode="multiply",
    #         restitution_combine_mode="multiply",
    #         static_friction=1.0,
    #         dynamic_friction=1.0,
    #     ),
    #     debug_vis=False,
    # )
    
    # -------------------------------------------------------------------------
    # 【範例 3】隨機起伏地形（取消註解即可使用）
    # -------------------------------------------------------------------------
    # terrain = TerrainImporterCfg(
    #     prim_path="/World/ground",
    #     terrain_type="generator",
    #     terrain_generator=TerrainGeneratorCfg(
    #         size=(8.0, 8.0),
    #         num_rows=4,
    #         num_cols=4,
    #         sub_terrains={
    #             "random_rough": hf.HfRandomUniformTerrainCfg(
    #                 proportion=1.0,
    #                 noise_range=(-0.05, 0.05),  # 地面高度變化 ±5 公分
    #                 noise_step=0.005,           # 最小高度變化量
    #                 downsampled_scale=0.2,      # 採樣解析度
    #             ),
    #         },
    #     ),
    #     collision_group=-1,
    #     physics_material=sim_utils.RigidBodyMaterialCfg(
    #         static_friction=1.0,
    #         dynamic_friction=1.0,
    #     ),
    # )
    
    # -------------------------------------------------------------------------
    # 【範例 4】混合地形（多種地形組合，取消註解即可使用）
    # -------------------------------------------------------------------------
    # terrain = TerrainImporterCfg(
    #     prim_path="/World/ground",
    #     terrain_type="generator",
    #     terrain_generator=TerrainGeneratorCfg(
    #         size=(8.0, 8.0),
    #         num_rows=8,
    #         num_cols=8,
    #         curriculum=True,        # 啟用課程學習：由簡到難
    #         sub_terrains={
    #             # 平坦地形佔 20%（最簡單）
    #             "flat": mesh.MeshPlaneTerrainCfg(
    #                 proportion=0.2,
    #             ),
    #             # 隨機起伏佔 30%（中等難度）
    #             "rough": hf.HfRandomUniformTerrainCfg(
    #                 proportion=0.3,
    #                 noise_range=(-0.03, 0.03),
    #                 noise_step=0.005,
    #             ),
    #             # 金字塔階梯佔 30%（較難）
    #             "stairs": hf.HfPyramidStairsTerrainCfg(
    #                 proportion=0.3,
    #                 step_height_range=(0.05, 0.1),
    #                 step_width=0.25,
    #             ),
    #             # 波浪地形佔 20%（困難）
    #             "wave": hf.HfWaveTerrainCfg(
    #                 proportion=0.2,
    #                 amplitude_range=(0.02, 0.06),
    #                 num_waves=2,
    #             ),
    #         },
    #     ),
    #     collision_group=-1,
    #     physics_material=sim_utils.RigidBodyMaterialCfg(
    #         static_friction=1.0,
    #         dynamic_friction=1.0,
    #     ),
    # )

    # =========================================================================
    # 【關節名稱對照表】把關節編號與位置對應起來
    # =========================================================================
    # 
    # 機器人腿的物理佈局（俯視圖）：
    # 
    #              前方 (Forward +X)
    #                   ^
    #                   |
    #        ┌─────────────────────┐
    #        │                     │
    #   Leg1 ●─────────────────────● Leg4    (前排)
    #        │                     │
    #        │      [機身]         │
    #        │                     │
    #   Leg2 ●─────────────────────● Leg5    (中排)
    #        │                     │
    #        │                     │
    #        │                     │
    #   Leg3 ●─────────────────────● Leg6    (後排)
    #        │                     │
    #        └─────────────────────┘
    #       右側                  左側
    #
    # 【關節編號對應】
    # ┌──────────────────────────────────────────────────────────────────────┐
    # │ 腿編號 │ 位置   │ 主驅動關節  │ ABAD 關節  │ 避震關節  │ Tripod 組 │
    # ├──────────────────────────────────────────────────────────────────────┤
    # │ Leg 1  │ 右前   │ Revolute_15 │ Revolute_14│ Revolute_5 │ A 組      │
    # │ Leg 2  │ 右中   │ Revolute_7  │ Revolute_6 │ Revolute_8 │ B 組      │
    # │ Leg 3  │ 右後   │ Revolute_12 │ Revolute_11│ Revolute_13│ B 組      │
    # │ Leg 4  │ 左前   │ Revolute_18 │ Revolute_17│ Revolute_25│ A 組      │
    # │ Leg 5  │ 左中   │ Revolute_23 │ Revolute_22│ Revolute_26│ B 組      │
    # │ Leg 6  │ 左後   │ Revolute_24 │ Revolute_21│ Revolute_27│ A 組      │
    # └──────────────────────────────────────────────────────────────────────┘
    #
    # 【Tripod 分組原理】（交替支撐，確保穩定）
    # - Tripod A: Leg1 + Leg4 + Leg6 = 右前 + 左前 + 左後（三角形支撐）
    # - Tripod B: Leg2 + Leg3 + Leg5 = 右中 + 右後 + 左中（另一個三角形）
    # 兩組交替著地，任何時刻都有三點支撐！
    
    # -------------------------------------------------------------------------
    # 主驅動關節名稱列表
    # -------------------------------------------------------------------------
    # 順序：[右前, 右中, 右後, 左前, 左中, 左後]
    # 索引：[  0,    1,    2,    3,    4,    5  ]
    main_drive_joint_names = [
        "Revolute_15",  # 索引 0 - Leg 1 (右前) - 屬於 Tripod A
        "Revolute_7",   # 索引 1 - Leg 2 (右中) - 屬於 Tripod B
        "Revolute_12",  # 索引 2 - Leg 3 (右後) - 屬於 Tripod B
        "Revolute_18",  # 索引 3 - Leg 4 (左前) - 屬於 Tripod A
        "Revolute_23",  # 索引 4 - Leg 5 (左中) - 屬於 Tripod B
        "Revolute_24",  # 索引 5 - Leg 6 (左後) - 屬於 Tripod A
    ]
    
    # -------------------------------------------------------------------------
    # 腿旋轉方向乘數
    # -------------------------------------------------------------------------
    # 為什麼需要這個？
    # 因為左右兩側的腿面對面，要讓機器人往前走：
    # - 右側腿需要「逆時針」轉（從右邊看）→ 乘數 -1
    # - 左側腿需要「順時針」轉（從左邊看）→ 乘數 +1
    leg_direction_multiplier = [-1.0, -1.0, -1.0, 1.0, 1.0, 1.0]
    
    # -------------------------------------------------------------------------
    # ABAD 關節名稱列表（順序對應主驅動關節）
    # -------------------------------------------------------------------------
    abad_joint_names = [
        "Revolute_14",  # Leg 1 (右前)
        "Revolute_6",   # Leg 2 (右中)
        "Revolute_11",  # Leg 3 (右後)
        "Revolute_17",  # Leg 4 (左前)
        "Revolute_22",  # Leg 5 (左中)
        "Revolute_21",  # Leg 6 (左後)
    ]
    
    # -------------------------------------------------------------------------
    # 避震關節名稱列表（順序對應主驅動關節）
    # -------------------------------------------------------------------------
    damper_joint_names = [
        "Revolute_5",   # Leg 1 (右前)
        "Revolute_8",   # Leg 2 (右中)
        "Revolute_13",  # Leg 3 (右後)
        "Revolute_25",  # Leg 4 (左前)
        "Revolute_26",  # Leg 5 (左中)
        "Revolute_27",  # Leg 6 (左後)
    ]

    # =========================================================================
    # 【Tripod 分組索引】用於步態控制
    # =========================================================================
    # RHex 的交替三足步態工作原理：
    # 1. Tripod A 的三隻腳同時著地、同時離地
    # 2. Tripod B 的三隻腳同時著地、同時離地
    # 3. A 和 B 使用「非對稱 duty cycle」交替進行
    #    ★ 著地相位：時間長（65%）但角度小（60°），腿緩慢轉動
    #    ★ 擺動相位：時間短（35%）但角度大（300°），腿快速轉動
    # 
    # 這樣的好處：
    # - 因為 duty_cycle > 50%，兩組著地時間有 30% 重疊
    # - 任何時刻都至少有一組著地，永不騰空！
    # - 運動效率高（類似昆蟲的走路方式）
    
    # Tripod A 組：索引 0, 3, 5 → 對應關節 15, 18, 24
    tripod_a_leg_indices = [0, 3, 5]
    
    # Tripod B 組：索引 1, 2, 4 → 對應關節 7, 12, 23
    tripod_b_leg_indices = [1, 2, 4]
    
    # =========================================================================
    # 【左右側分組】用於控制轉向
    # =========================================================================
    # 右側腿：索引 0, 1, 2（對應關節 15, 7, 12）
    right_leg_indices = [0, 1, 2]
    
    # 左側腿：索引 3, 4, 5（對應關節 18, 23, 24）
    left_leg_indices = [3, 4, 5]

    # =========================================================================
    # 【動作縮放參數】把 AI 輸出轉換成實際的控制值
    # =========================================================================
    # AI 神經網路輸出的數值範圍是 [-1, +1]
    # 我們需要把這些數值縮放成實際有意義的物理量
    
    # 主驅動關節：目標角速度（弧度/秒）
    # AI 輸出 [-1, +1] × 8.0 = 實際速度 [-8, +8] rad/s
    # 8 rad/s ≈ 每秒轉 1.3 圈，這讓腿能快速旋轉推進機器人
    main_drive_vel_scale = 8.0
    
    # ABAD 關節：目標位置偏移（弧度）
    # AI 輸出 [-1, +1] × 0.3 = 實際角度偏移 [-0.3, +0.3] rad ≈ ±17 度
    # 這是腿可以向外/向內擺動的範圍
    abad_pos_scale = 0.61096  # 約等於 35 度

    # =========================================================================
    # 【速度命令範圍】定義機器人可以執行的移動指令
    # =========================================================================
    # 在訓練過程中，系統會隨機給機器人下達移動命令
    # 機器人必須學會追蹤這些命令（往前走、往左走、轉彎等）
    
    # 前後速度範圍（公尺/秒）
    # ★★★ RHex 只適合向前走，不設計向後 ★★★
    # 正值 = 向前移動，負值 = 向後移動（已禁用）
    lin_vel_x_range = [0.0, 0.5]
    
    # 側向速度範圍（公尺/秒）
    # 正值 = 向左移動，負值 = 向右移動
    lin_vel_y_range = [-0.3, 0.3]
    
    # 旋轉速度範圍（弧度/秒）
    # 正值 = 逆時針旋轉，負值 = 順時針旋轉
    ang_vel_z_range = [-1.0, 1.0]
    
    # 命令重新採樣時間（秒）
    # 每隔這麼多秒，系統會隨機給一個新的移動命令
    # 這讓機器人學會應對各種不同的移動要求
    command_resample_time = 6.0
    
    # -------------------------------------------------------------------------
    # 離散方向模式：使用預定義的移動方向
    # -------------------------------------------------------------------------
    # 如果設為 True，系統會從下面的列表中隨機選擇一個方向
    # 而不是隨機生成連續的速度值
    use_discrete_directions = True
    
    # 7 個預定義的移動方向 [前後速度, 左右速度, 旋轉速度]
    # ★★★ 注意：RHex 不適合向後走，所以移除所有後退方向 ★★★
    discrete_directions = [
        [0.4, 0.0, 0.0],     # 方向 0: 直走（向前）
        [0.0, 0.3, 0.0],     # 方向 1: 側移（向左）
        [0.0, -0.3, 0.0],    # 方向 2: 側移（向右）
        [0.3, 0.2, 0.0],     # 方向 3: 斜走（左前方）
        [0.3, -0.2, 0.0],    # 方向 4: 斜走（右前方）
        [0.0, 0.0, 0.8],     # 方向 5: 原地旋轉（逆時針）
        [0.0, 0.0, -0.8],    # 方向 6: 原地旋轉（順時針）
    ]
    
    # 方向名稱（用於調試輸出，方便查看機器人正在追蹤什麼命令）
    direction_names = ["前", "左", "右", "左前", "右前", "逆時針旋轉", "順時針旋轉"]
    
    # -------------------------------------------------------------------------
    # 調試視覺化設定
    # -------------------------------------------------------------------------
    # 是否在模擬畫面上繪製調試箭頭（顯示速度方向等）
    draw_debug_vis = True
    
    # 每隔幾個時間步更新一次視覺化（減少效能負擔）
    debug_vis_interval = 5

    # =========================================================================
    # 【步態參數】RHex 非對稱 Duty Cycle 步態 - 詳細說明
    # =========================================================================
    # 
    # ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    # ★ RHex 真正的步態模式（非簡單 180° 反相！）                          ★
    # ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    # 
    # 【核心概念】
    # RHex 的步態不是讓兩組腿簡單地 180° 反相旋轉！
    # 如果那樣做，會有很大部分時間機器人完全沒有腳撐著地板。
    # 
    # 真正的 RHex 步態是：
    # 1. 一組著地時「慢慢轉」(Stance Phase) - 提供穩定支撐和推進力
    # 2. 另一組在空中「快速轉一圈」(Swing Phase) - 快速回到準備著地的相位
    # 3. 當擺動組轉完一圈回到著地相位時，著地組才開始快轉
    # 4. 這樣確保任何時刻都至少有一組（3隻腳）在地面支撐！
    # 
    # =========================================================================
    # 【時間軸圖解】一個完整週期（T = 1秒，假設 1Hz）
    # =========================================================================
    # 
    # 時間: |----0.0s----|----0.2s----|----0.4s----|----0.6s----|----0.8s----|----1.0s----|
    #       |            |            |            |            |            |            |
    # 
    # Tripod A:
    #       |████████████████████████████████████████|░░░░░░░░░░░░░░░░░░░░░░|████████...
    #       |<------- 著地相位 (慢轉 ~65%) -------->|<-- 擺動相位 (快轉) ->|
    #       |  腿接觸地面，緩慢旋轉推進機身           |  腿離地，快速轉一圈   |
    #       |  相位: 0° → 234°                       |  相位: 234° → 360°   |
    #       |  速度: ~3.4 rad/s (慢)                 |  速度: ~11.7 rad/s   |
    # 
    # Tripod B:
    #       |░░░░░░░░░░░░░░░░░░░░░░|████████████████████████████████████████|░░░░░░░...
    #       |<-- 擺動相位 (快轉) ->|<------- 著地相位 (慢轉 ~65%) -------->|
    #       |  B組快速轉完一圈     |  B組著地，A組開始快轉                   |
    # 
    # 支撐狀態:
    #       |████████████████████████████████████████|████████████████████████████████...
    #       |<--------------- A組支撐 ------------->|<------------ B組支撐 ----------->|
    #       |                                        |
    #       |                                   交接點：B組剛著地，A組準備離地
    # 
    # █ = 著地支撐（Stance）- 緩慢旋轉，提供推力
    # ░ = 空中擺動（Swing） - 快速旋轉，準備下次著地
    # 
    # =========================================================================
    # 【相位角度定義】（C型腿的旋轉位置）
    # =========================================================================
    #
    #                    0° (著地開始)
    #                      │
    #                 ─────┼─────
    #                /     │     \
    #               /      │      \
    #       270°   │   [C型腿]    │   90°
    #               \      │      /
    #                \     │     /
    #                 ─────┼─────
    #                      │
    #                   180°
    #
    # 相位 0° ~ 234°（約 65% 週期）：著地相位（腿底部接觸地面）
    # 相位 234° ~ 360°（約 35% 週期）：擺動相位（腿在空中快轉）
    #
    # =========================================================================
    # 【速度計算原理】★★★ 重要：角度 vs 時間 的區別 ★★★
    # =========================================================================
    #
    # 【核心概念】著地時間長，但轉過角度少！
    #
    # 因為著地時腿底部要維持在地面（大約在相位 0° 附近），
    # 所以著地階段轉過的「角度」很少，只是時間拉長。
    #
    # 設一個完整週期為 T 秒，設基礎轉速為 ω_base
    #
    # 【關鍵洞見】
    # 著地時：腿底部朝下接觸地面，相位在「著地區間」(例如 -30° ~ +30°)
    #        在這個小區間內慢慢轉，花費 65% 的時間
    #
    # 擺動時：腿要從 +30° 快速轉過 300°，回到 -30° (下一圈的著地位置)
    #        只花 35% 的時間完成這一大段
    #
    # 【數學計算】
    # 假設著地區間角度 = α_stance (例如 60° = π/3 rad)
    # 假設擺動區間角度 = α_swing = 360° - α_stance = 300° (例如 5π/3 rad)
    #
    # 著地速度 = α_stance / (duty_cycle × T)
    #          = (π/3) / (0.65 × T)  ← 小角度、長時間 → 很慢
    #
    # 擺動速度 = α_swing / ((1-duty_cycle) × T)
    #          = (5π/3) / (0.35 × T)  ← 大角度、短時間 → 很快！
    #
    # 速度比例 = 擺動速度 / 著地速度
    #          = (5π/3 / 0.35) / (π/3 / 0.65)
    #          = (5 × 0.65) / (1 × 0.35)
    #          = 3.25 / 0.35 ≈ 9.3 倍！
    #
    # 所以擺動速度應該是著地速度的 ~10 倍左右
    #
    # =========================================================================
    
    # -------------------------------------------------------------------------
    # 【基礎頻率參數】
    # -------------------------------------------------------------------------
    # 基礎步態頻率（赫茲 Hz）
    # 1.0 Hz = 機器人每秒完成一個完整的「左右交替」週期
    base_gait_frequency = 1.0
    
    # 基礎角速度（用於計算實際速度）
    # 這是「平均」概念上的速度，實際會根據相位調整
    base_gait_angular_vel = 2 * math.pi * 1.0  # ≈ 6.28 rad/s
    
    # -------------------------------------------------------------------------
    # 【非對稱 Duty Cycle 核心參數】
    # -------------------------------------------------------------------------
    
    # stance_duty_cycle: 著地相位佔整個週期的比例
    # 
    # 這個值決定了「穩定性 vs 速度」的平衡：
    # - 0.5 = 各佔一半（不推薦，會有空檔期）
    # - 0.6 = 著地 60%，擺動 40%
    # - 0.65 = 著地 65%，擺動 35%（推薦值）
    # - 0.7 = 著地 70%，擺動 30%（更穩但更慢）
    #
    # 設為 0.65 表示：
    # - 一組腿在地面支撐的時間佔 65%
    # - 在空中快轉的時間只佔 35%
    # - 這確保兩組輪換時有足夠的「重疊」時間
    stance_duty_cycle = 0.65
    
    # -------------------------------------------------------------------------
    # 【速度比例參數】★ 關鍵參數 ★
    # -------------------------------------------------------------------------
    #
    # 這兩個參數決定了著地/擺動時的實際旋轉速度
    #
    # 【重要】著地速度很慢，擺動速度很快！
    #
    # stance_velocity_ratio: 著地時的速度 = base_vel × 這個值
    # - 著地時腿底部在地面，只能慢慢轉過一個小角度
    # - 建議值: 0.1 ~ 0.3（非常慢！）
    # - 0.15 表示著地時以基礎速度的 15% 旋轉
    stance_velocity_ratio = 0.15

    # swing_velocity_ratio: 擺動時的速度 = base_vel × 這個值
    # - 擺動時要快速轉過大部分角度（約 300°）
    # - 建議值: 1.5 ~ 2.5
    # - 擺動速度需要約是著地速度的 10 倍！
    swing_velocity_ratio = 1.5

    # 【速度計算公式】
    # 著地速度 = base_gait_angular_vel × stance_velocity_ratio
    #          = 6.28 × 0.15 = 0.94 rad/s (非常慢，一秒轉約 54°)
    #
    # 擺動速度 = base_gait_angular_vel × swing_velocity_ratio
    #          = 6.28 × 1.5 = 9.42 rad/s (快速，一秒轉約 540°)
    #
    # 速度比 = 1.5 / 0.15 = 10 倍

    # -------------------------------------------------------------------------
    # 【相位區間定義】★★★ 這是「角度」不是「時間」！★★★
    # -------------------------------------------------------------------------
    #
    # C型腿的相位角（0 ~ 2π）：
    # - 0 = 腿的「腳底」正朝下（最佳著地位置）
    # - π = 腿的「腳底」朝上（在空中最高點）
    # - 2π = 回到起點
    #
    # 【關鍵理解】
    # 著地相位的「角度區間」很小（腳底要維持朝下接觸地面）
    # 但著地相位的「時間」很長（65%）
    # 這意味著在這個小角度區間內慢慢轉

    # 著地相位開始角度（弧度）
    # 負值表示從「剛要接觸地面」開始
    # -π/6 ≈ -30° (腳底稍微向前)
    stance_phase_start = -math.pi / 6

    # 著地相位結束角度（弧度）
    # +π/6 ≈ +30° (腳底稍微向後)
    # 著地區間總共只有 60°！（但花 65% 的時間）
    stance_phase_end = math.pi / 6

    # 擺動相位範圍：+30° → 330°（-30° + 360°）
    # 這是一個大角度區間（300°），但只花 35% 的時間
    # 所以擺動時腿要「飛快」地轉過去！
    
    # -------------------------------------------------------------------------
    # 【兩組 Tripod 的相位關係】★ 關鍵理解 ★
    # -------------------------------------------------------------------------
    # 
    # 傳統錯誤理解：A 和 B 相位差 180°
    # 正確理解：A 和 B 的「著地時間」錯開，確保連續支撐
    # 
    # 時序說明：
    # 1. 時刻 0：A組在著地相位（0°），B組在擺動相位末端（接近360°）
    # 2. B組快速轉完，進入著地相位
    # 3. A組繼續慢轉，當A組即將離開著地相位時...
    # 4. B組已經在著地相位中段，可以接手支撐
    # 5. A組開始快轉（擺動相位）
    # 6. A組轉完一圈，回到著地相位，此時B組即將開始擺動
    # 7. 循環...
    # 
    # 關鍵：由於 duty_cycle > 0.5，兩組的著地時間有「重疊」！
    # 重疊時間 = (2 × duty_cycle - 1) × T = (2×0.65-1) × 1s = 0.3s
    # 這 0.3 秒是「交接期」，兩組都在地面，超級穩定！
    
    # tripod_phase_offset: 兩組之間的初始相位差
    # 這個值影響兩組的「錯開程度」
    # π (180°) 是一個合理的初始值，但實際行為由 duty cycle 決定
    tripod_phase_offset = math.pi
    
    # -------------------------------------------------------------------------
    # 【給 AI 的相位觀測】
    # -------------------------------------------------------------------------
    # AI 需要知道每組腿現在處於什麼相位，才能做出正確的速度決策
    # 
    # 我們提供給 AI 的觀測：
    # 1. 全局步態時鐘相位 (gait_phase): 0 ~ 2π 循環
    # 2. 每隻腿的當前相位 (leg_phase): 從關節角度計算
    # 3. 每隻腿是否在「著地區間」的布林值
    
    # -------------------------------------------------------------------------
    # 【速度指令生成邏輯】（在 env.py 中實現）
    # -------------------------------------------------------------------------
    # 對於每隻腿：
    # 1. 計算當前相位角 θ
    # 2. 判斷是否在著地區間：stance_phase_start ≤ θ < stance_phase_end
    # 3. 如果在著地區間：目標速度 = base_vel × stance_velocity_ratio
    # 4. 如果在擺動區間：目標速度 = base_vel × swing_velocity_ratio
    # 5. AI 可以微調這個速度（±50%），但不能完全停下來

    # =========================================================================
    # 【獎勵函數權重】參考 ETH Zurich legged_gym 標準配置
    # =========================================================================
    #
    # 參考來源：https://github.com/leggedrobotics/legged_gym
    # 論文：Learning to Walk in Minutes (CoRL 2021)
    #
    # 【設計原則】
    # 1. 追蹤獎勵使用 exp(-error²/sigma) 形式，sigma=0.25
    # 2. 懲罰項通常使用平方誤差
    # 3. 權重量級：追蹤 ~1.0, 懲罰 ~0.01-0.1, 碰撞 ~-1.0
    # 4. 使用 only_positive_rewards=True 避免早期終止問題
    #
    # =========================================================================

    # -------------------------------------------------------------------------
    # G1: 速度追蹤獎勵（核心目標）
    # -------------------------------------------------------------------------
    # legged_gym 標準: tracking_lin_vel=1.0, tracking_ang_vel=0.5
    # 追蹤公式: reward = exp(-error²/sigma), sigma=0.25
    # 
    # ★ 提高權重讓機器人更積極移動 ★

    # 線速度追蹤（前後 + 左右）
    rew_scale_track_lin_vel = 2.0  # 提高從 1.0 → 2.0

    # 角速度追蹤（旋轉）
    rew_scale_track_ang_vel = 1.0  # 提高從 0.5 → 1.0

    # 追蹤獎勵的 sigma 參數（控制獎勵衰減速度）
    # 較小的 sigma 讓獎勵衰減更快，迫使更精確追蹤
    tracking_sigma = 0.20  # 從 0.25 → 0.20

    # -------------------------------------------------------------------------
    # G2: 姿態穩定性懲罰
    # -------------------------------------------------------------------------
    # legged_gym 標準值

    # Z軸線速度懲罰（不要上下跳）
    # legged_gym: lin_vel_z = -2.0
    rew_scale_z_vel = -2.0

    # XY軸角速度懲罰（不要翻滾）
    # legged_gym: ang_vel_xy = -0.05
    rew_scale_ang_vel_xy = -0.05

    # 姿態懲罰（保持直立）
    # legged_gym: orientation = -0.0 (通常不用，由其他項覆蓋)
    rew_scale_upright = -0.0

    # 基座高度懲罰
    # legged_gym: base_height = -0.0
    rew_scale_base_height = -0.0

    # -------------------------------------------------------------------------
    # G3: 碰撞懲罰
    # -------------------------------------------------------------------------
    # legged_gym: collision = -1.0

    # 身體觸地懲罰
    rew_scale_body_contact = -1.0

    # 是否在身體觸地時終止
    terminate_on_body_contact = True

    # 觸地高度閾值（公尺）
    body_contact_height_threshold = 0.02

    # -------------------------------------------------------------------------
    # G4: 能耗與動作平滑懲罰
    # -------------------------------------------------------------------------
    # legged_gym 標準值

    # 力矩懲罰
    # legged_gym: torques = -0.00001
    rew_scale_torque = -0.000005  # 降低，讓機器人更敢用力

    # 動作變化率懲罰
    # legged_gym: action_rate = -0.01
    # ★★★ 提高此值以抑制高頻抖動 ★★★
    rew_scale_action_rate = -0.05  # 提高 10 倍：-0.005 → -0.05

    # 關節加速度懲罰
    # legged_gym: dof_acc = -2.5e-7
    rew_scale_joint_acc = -1.0e-7  # 降低

    # 關節速度懲罰（可選，legged_gym: dof_vel = -0.0）
    rew_scale_dof_vel = -0.0
    
    # ABAD 動作變化率額外懲罰（抑制 ABAD 抖動）
    rew_scale_abad_action_rate = -0.1

    # -------------------------------------------------------------------------
    # G5: RHex 步態專用獎勵
    # -------------------------------------------------------------------------
    # 這些是針對 RHex 特殊步態設計的獎勵
    # 權重相對較小，讓主要追蹤獎勵主導學習

    # 組內同步（Tripod A/B 內部腿的相位一致）
    rew_scale_tripod_sync = 0.2

    # 連續支撐獎勵（確保有腿著地）
    # 類似 legged_gym 的 feet_air_time = 1.0
    rew_scale_tripod_support = 1.0

    # 騰空懲罰（兩組都在空中）
    rew_scale_airborne_penalty = -1.0

    # 速度比例正確性（著地慢、擺動快）
    rew_scale_duty_cycle_velocity = 0.5

    # 相位轉換平滑
    rew_scale_phase_transition_smooth = 0.1

    # 步態頻率一致性
    rew_scale_gait_frequency = 0.2

    # 組間交替
    rew_scale_tripod_alternation = 0.3

    # 舊版反相獎勵（停用）
    rew_scale_tripod_antiphase = 0.0
    
    # -------------------------------------------------------------------------
    # G6: ABAD 關節使用策略
    # -------------------------------------------------------------------------
    # ABAD 用於轉彎和側移，直走時應該保持穩定

    # ABAD 聰明使用獎勵
    rew_scale_abad_smart_use = 0.5  # 提高，鼓勵側移時使用 ABAD

    # ABAD 浪費懲罰
    rew_scale_abad_waste = -0.1  # 提高，直走時不要亂用

    # -------------------------------------------------------------------------
    # G6.5: 側移步態專用獎勵 ★★★ 新增 ★★★
    # -------------------------------------------------------------------------
    # 這些獎勵專門用於純側移（正左/正右）時的步態控制
    # 目標步態：ABAD 交替外展內收，一組抬腿一組著地
    
    # ABAD 交替獎勵：左右兩側 ABAD 動作應該反向（一邊外展一邊內收）
    rew_scale_abad_alternation = 2.0
    
    # ABAD 幅度獎勵：側移時 ABAD 應該有足夠的擺幅
    rew_scale_abad_amplitude = 1.0
    
    # 抖動懲罰：懲罰 ABAD 的高頻小幅抖動
    rew_scale_abad_jitter = -3.0
    
    # 同步抖動懲罰：懲罰所有腿同時高頻動作
    rew_scale_sync_jitter = -5.0
    
    # 側移腳離地獎勵：側移時應該有腳離地（通過主驅動相位判斷）
    rew_scale_lateral_lift = 1.5
    
    # -------------------------------------------------------------------------
    # G7: 額外獎勵
    # -------------------------------------------------------------------------

    # 存活獎勵（設為 0 避免懶惰策略）
    rew_scale_alive = 0.0

    # 終止懲罰
    # legged_gym: termination = -0.0
    rew_scale_termination = -0.0

    # -------------------------------------------------------------------------
    # 獎勵裁剪設定
    # -------------------------------------------------------------------------
    # legged_gym: only_positive_rewards = True
    # 將負總獎勵裁剪為 0，避免早期終止問題
    only_positive_rewards = True

    # -------------------------------------------------------------------------
    # 舊版變數（為了相容性保留）
    # -------------------------------------------------------------------------
    rew_scale_forward_vel = 1.0
    rew_scale_vel_tracking = 0.5
    rew_scale_gait_sync = 0.2
    rew_scale_smooth_rotation = 0.0
    rew_scale_rotation_direction = 0.5
    rew_scale_orientation = -0.0
    rew_scale_lin_vel_z = -2.0
    rew_scale_abad_action = 0.0
    rew_scale_abad_stability = 0.1
    rew_scale_drive_acc = 0.0
    rew_scale_collision = -1.0

    # =========================================================================
    # 【終止條件】定義什麼情況下結束這一回合
    # =========================================================================
    # 當機器人狀態太糟糕時，與其繼續浪費時間，不如重新開始
    
    # 最大傾斜角度（弧度）
    # 超過這個角度就視為「翻倒」，結束回合
    max_tilt_magnitude = 1.5
    
    # 最低高度（公尺）
    # 機身低於這個高度就視為「趴下」，結束回合
    min_base_height = 0.02
    
    # 最高高度（公尺）
    # 機身高於這個高度就視為「異常」（可能是 bug），結束回合
    max_base_height = 0.8

    # =========================================================================
    # 【領域隨機化】讓訓練更強健
    # =========================================================================
    # 
    # 【什麼是領域隨機化？】
    # 在訓練時故意加入各種隨機變化，讓 AI 見過各種情況
    # 這樣訓練出來的 AI 更能適應真實世界的不確定性
    # 
    # 就像訓練一個廚師：
    # - 如果只在同一個廚房練習 → 換個廚房就不會做了
    # - 如果在各種不同的廚房練習 → 到哪都能做菜
    
    # -------------------------------------------------------------------------
    # 質量隨機化
    # -------------------------------------------------------------------------
    randomize_mass = True        # 啟用質量隨機化
    mass_range = [0.9, 1.1]      # 質量變化範圍：原始質量的 90% ~ 110%

    # -------------------------------------------------------------------------
    # 摩擦力隨機化
    # -------------------------------------------------------------------------
    randomize_friction = True    # 啟用摩擦力隨機化
    friction_range = [0.5, 1.25] # 摩擦係數範圍：0.5 倍 ~ 1.25 倍

    # -------------------------------------------------------------------------
    # 關節摩擦隨機化
    # -------------------------------------------------------------------------
    randomize_joint_friction = True   # 啟用關節摩擦隨機化
    joint_friction_range = [0.0, 0.05] # 關節摩擦範圍

    # -------------------------------------------------------------------------
    # 隨機推擠(尚未實現)
    # -------------------------------------------------------------------------
    # 偶爾給機器人一個推力，測試它的穩定性
    push_robots = True           # 啟用隨機推擠
    push_interval_s = 15.0       # 每 15 秒推一次
    max_push_vel_xy = 0.5        # 最大推擠速度（公尺/秒）

    # =========================================================================
    # 【觀測噪音】模擬真實感測器的誤差
    # =========================================================================
    # 真實世界的感測器都有誤差，訓練時加入噪音讓 AI 更能適應
    
    add_noise = True             # 啟用噪音
    noise_level = 1.0            # 噪音強度倍數

    # 各種觀測值的噪音大小
    noise_lin_vel = 0.1          # 線速度噪音
    noise_ang_vel = 0.2          # 角速度噪音
    noise_gravity = 0.05         # 重力方向噪音
    noise_joint_pos = 0.01       # 關節位置噪音
    noise_joint_vel = 1.5        # 關節速度噪音
